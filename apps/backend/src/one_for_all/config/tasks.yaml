account_creation_task:
  description: >
    Use provided profile data for account creation:
    - Full Name: {full_name}
    - Email: {email}
    - Mobile: {mobile_number}
    - WhatsApp: {whatsapp_number}
    Verify information is correct. Select OTP method (WhatsApp preferred).
    Your final answer MUST include: username, email, cellphone, chosen_otp_method.
  expected_output: >
    A structured JSON object with user credentials ready for OTP sending.
  agent: identity_auth_agent

otp_verification_task:
  description: >
    Send the OTP based on the user's selected method (email, SMS, or WhatsApp).
    The OTP sending tools (sendgrid_otp_sender, sms_otp_sender, send_whatsapp_otp)
    will AUTOMATICALLY generate and store the OTP in the database - do NOT
    fabricate OTP codes.

    After sending, prompt the user to provide the OTP they received.

    Use the verify_otp tool to validate the code against the database:
    - verify_otp(identifier, code) returns "OTP_VALID" or "OTP_INVALID: reason"
    - identifier must match exactly what was used when sending (email or phone)

    ONLY after receiving "OTP_VALID" response:
    - Create user account via supabase_user_store
    - Create 24hr session via supabase_session_create

    If verification fails, inform the user of the specific reason and offer
    to resend using resend_otp_check tool first.

    Your final answer MUST confirm successful account creation with session token.
  expected_output: >
    Confirmation message with session token (only after OTP_VALID verification).
  agent: identity_auth_agent

collect_personal_info_task:
  description: >
    Use provided profile data for personal information:
    - Full Name: {full_name}
    - SA ID Number: {id_number}
    - Date of Birth: {date_of_birth}
    - Gender: {gender}
    - Citizenship: {citizenship}
    - Home Address: {physical_address}
    - Email: {email}
    - Cellphone: {mobile_number}
    - Province: {province}
    - Home Language: {home_language}
    Confirm all data is correct. Your final answer MUST be a structured JSON.
  expected_output: >
    SA-standardised applicant personal information.
  agent: application_intake_agent

collect_academic_info_task:
  description: >
    Use provided academic data from profile:
    - Matric Results: {matric_results}
    - Total APS Score: {total_aps_score}
    - Academic Highlights: {academic_highlights}
    Confirm data is correct. Your final answer MUST be a JSON matching SA requirements.
  expected_output: >
    Detailed SA academic history JSON with APS score.
  agent: application_intake_agent

collect_documents_task:
  description: >
    Use provided document status from profile:
    - Available: {documents_available}
    - Missing: {documents_missing}
    Mark available documents as "uploaded", missing as "pending".
    Do NOT block workflow for missing documents.
    Your final answer MUST include document metadata with status per document.
  expected_output: >
    Document metadata JSON with status field per document (uploaded/pending).
  agent: application_intake_agent
  context:
    - collect_personal_info_task
    - collect_academic_info_task

document_validation_task:
  description: >
    Validate all collected documents for the application.
    TIER 1: Rule-based checks (format, size, required types)
    TIER 2: AI vision analysis (only for uncertain cases)
    BLOCKING: If required documents fail, return VALIDATION_FAILED

    Required documents for university applications:
    - ID document
    - Matric certificate (or latest results)
    - Proof of residence

    Validation results must be stored in application_documents.
    If validation fails, notify applicant via WhatsApp with specific issues.
  expected_output: >
    JSON with:
    - validation_passed: boolean
    - documents_validated: list of validated doc IDs
    - documents_flagged: list of flagged docs with reasons
    - missing_required: list of missing document types
    Example: {"validation_passed": true, "documents_validated": ["doc-123", "doc-456"], "documents_flagged": [], "missing_required": []}
  agent: document_reviewer_agent
  context:
    - collect_personal_info_task
    - collect_documents_task

program_selection_task:
  description: >
    Use provided course selections from profile:
    - Course Choices: {course_choices}
    - Primary Institution: {primary_institution}
    The course_choices array contains first and second choice with priority.
    Verify selections align with APS score ({total_aps_score}).
    Your final answer MUST include first_choice and second_choice per university.
  expected_output: >
    JSON list of universities with first_choice and second_choice course details.
  agent: application_intake_agent
  context:
    - collect_academic_info_task

rag_research_task:
  description: >
    Evaluate eligibility for each course choice using profile data:
    - APS Score: {total_aps_score}
    - Matric Results: {matric_results}
    - Course Choices: {course_choices}

    The course_choices array may contain up to 3 choices:
    - Priority 1: First choice (original)
    - Priority 2: Second choice (original)
    - Priority 3: Fallback choice (use when first rejected)

    For EACH course choice:
    1. Check APS score against minimum requirement
    2. Check SUBJECT requirements (CRITICAL: Maths Literacy is NOT accepted for
       programmes requiring "Maths" - only pure Mathematics qualifies)
    3. Check language/other specific requirements

    ELIGIBILITY SCENARIOS:
    A) If FIRST-CHOICE ELIGIBLE: Use first + second as final choices
    B) If FIRST-CHOICE INELIGIBLE:
       - Mark as REJECTED with clear reason
       - Promote SECOND-CHOICE to NEW first-choice
       - Use FALLBACK (priority 3) as NEW second-choice if available
       - If no fallback provided, list eligible alternatives for prospect

    CRITICAL: Applications MUST have exactly TWO eligible choices.

    Your final answer MUST include:
    - original_first_choice_eligible (true/false) with reason
    - final_first_choice (programme name)
    - final_second_choice (programme name)
    - rejection_reasons (if any)
    - both_choices_verified (must be true)
  expected_output: >
    JSON with final_first_choice, final_second_choice, rejection_reasons,
    original_eligibility, and both_choices_verified=true.
  agent: rag_specialist_agent
  context:
    - collect_academic_info_task
    - program_selection_task

application_compilation_task:
  description: >
    Compile per university: personal info, academic info, documents (with status),
    BOTH course choices from RAG task (final_first_choice, final_second_choice).

    CRITICAL: Every application MUST have exactly TWO course choices:
    - first_choice: Primary programme (verified eligible)
    - second_choice: Backup programme (verified eligible)

    Use the RAG task output which has already verified eligibility and
    handled any promotions/replacements if original first choice was rejected.

    Validate all fields and prepare submission payload.
  expected_output: >
    Validated application JSON with BOTH first_choice and second_choice courses.
  agent: submission_agent
  context:
    - collect_personal_info_task
    - collect_academic_info_task
    - collect_documents_task
    - program_selection_task
    - rag_research_task

application_submission_task:
  description: >
    Submit to ALL selected universities using application_submission_tool.

    CRITICAL: Each submission MUST include BOTH choices:
    - first_choice: Primary programme
    - second_choice: Backup programme

    Do NOT submit applications with only one choice.

    Your final answer MUST include per university:
    - university name
    - application_id
    - first_choice_programme and status
    - second_choice_programme and status
    - overall submission status
  expected_output: >
    JSON with university, application_id, first_choice, second_choice, status.
  agent: submission_agent
  context:
    - application_compilation_task

ask_if_apply_for_nsfas_task:
  description: >
    Check profile for NSFAS eligibility:
    - NSFAS Eligible: {nsfas_eligible}
    - Household Income: {household_income}
    - SASSA Recipient: {sassa_recipient}

    DECISION LOGIC (check in order):
    1. If nsfas_eligible is FALSE or "No" → return NO_NSFAS (income too high)
    2. If postgrad programme → return NO_NSFAS (NSFAS is for undergrad only)
    3. If nsfas_eligible is TRUE and undergrad → return YES_NSFAS

    CRITICAL: High-income applicants (nsfas_eligible=false) must NOT apply for NSFAS.

    Your final answer MUST be exactly: "YES_NSFAS" or "NO_NSFAS"
  expected_output: >
    YES_NSFAS or NO_NSFAS
  agent: application_intake_agent
  context:
    - program_selection_task

nsfas_collection_task:
  description: >
    FIRST: Check the ask_if_apply_for_nsfas_task result in your context.

    IF the result was "NO_NSFAS":
      - Do NOT collect any NSFAS data
      - Do NOT call any tools
      - Return exactly: {"nsfas_skipped": true, "reason": "Applicant not eligible for NSFAS"}

    IF the result was "YES_NSFAS":
      Use profile data for NSFAS application:
      - Guardian Employment: {guardian_employment}
      - Household Income: {household_income}
      - SASSA Recipient: {sassa_recipient}
      - Disability Grant: {disability_grant}
      Reuse personal info, academic records from prior tasks.
      Compile NSFAS-specific fields. Store via supabase_nsfas_documents_store.
      Your final answer MUST be complete NSFAS application JSON.
  expected_output: >
    NSFAS application JSON with reused and new data combined, OR
    {"nsfas_skipped": true, "reason": "..."} if applicant not eligible.
  agent: nsfas_agent
  context:
    - ask_if_apply_for_nsfas_task
    - collect_personal_info_task
    - collect_academic_info_task
    - collect_documents_task

nsfas_submission_task:
  description: >
    FIRST: Check the nsfas_collection_task result in your context.

    IF the result contains "nsfas_skipped": true:
      - Do NOT submit any NSFAS application
      - Do NOT call any tools
      - Return exactly: {"nsfas_skipped": true, "reason": "Applicant not eligible for NSFAS - no submission required"}

    IF valid NSFAS application data exists:
      Submit NSFAS application via nsfas_application_submission_tool.
      Return: nsfas_application_id and submission status.
      Store application metadata in Supabase.
  expected_output: >
    NSFAS submission confirmation with nsfas_application_id, OR
    {"nsfas_skipped": true, "reason": "..."} if applicant not eligible.
  agent: nsfas_agent
  context:
    - nsfas_collection_task

university_status_check_task:
  description: >
    Retrieve status updates for university applications using
    application_status_tool.
    Your final answer MUST summarise the latest known status.
  expected_output: >
    Latest status update.
  agent: submission_agent

nsfas_status_check_task:
  description: >
    FIRST: Check the nsfas_submission_task result in your context.

    IF the result contains "nsfas_skipped": true:
      - Do NOT check any NSFAS status
      - Return exactly: "NSFAS application was not submitted - applicant not eligible for NSFAS funding due to household income exceeding threshold."

    IF NSFAS application was submitted:
      Retrieve the latest NSFAS application status using nsfas_status_tool.
      Your final answer MUST summarise:
        - current NSFAS status
        - any outstanding requirements
        - next steps for the student
  expected_output: >
    Latest NSFAS status summary, OR skip message if applicant not eligible.
  agent: nsfas_agent
  context:
    - nsfas_submission_task


document_review_task:
  description: >
    Review all uploaded documents for application {application_id}.

    STEPS:
    1. Use get_application_documents to fetch all documents for this application
    2. For each document, check:
       - Legibility: Can text/images be clearly read?
       - Completeness: Are all required pages present?
       - Accuracy: Does information match the applicant's details?
       - Validity: Check expiry dates where applicable (ID, certificates)

    3. For each document, make a decision:
       - Use document_approve_tool if the document is valid and complete
       - Use document_flag_tool if there are issues, providing a CLEAR reason

    FLAGGING REASONS MUST BE SPECIFIC AND ACTIONABLE:
    ✓ Good: "ID document image is too blurry - please upload a clearer photo"
    ✓ Good: "Matric certificate is missing page 2 - please upload complete document"
    ✗ Bad: "Document has issues"
    ✗ Bad: "Not acceptable"

    Your final answer MUST be a JSON with:
    - reviewed_count: Total documents reviewed
    - approved: Array of approved document IDs
    - flagged: Array of objects with {document_id, document_type, reason}
  expected_output: >
    JSON with reviewed_count, approved (array of IDs), flagged (array with document_id, document_type, reason)
  agent: document_reviewer_agent


document_flagging_notification_task:
  description: >
    For each flagged document from the document_review_task context,
    compose and send a notification to the applicant explaining what
    needs to be corrected and how to resubmit.

    NOTIFICATION GUIDELINES:
    1. Use applicant's preferred contact method (WhatsApp, Email, SMS)
    2. Be polite and helpful in tone
    3. Clearly state WHICH document has the issue
    4. Explain WHAT is wrong (use the flag_reason)
    5. Provide clear instructions on HOW to resubmit

    TEMPLATE STRUCTURE:
    Subject: Action Required - Document Review for Your Application

    Dear [Applicant Name],

    We have reviewed your application documents and need you to resubmit
    the following:

    Document: [Document Type]
    Issue: [Flag Reason]
    Action: Please upload a new version that addresses the issue above.

    [Include upload instructions or link]

    If you have questions, please contact support.

    Your final answer MUST confirm:
    - Number of notifications sent
    - Contact methods used
    - Brief summary of each notification
  expected_output: >
    Confirmation of notifications sent with message content summary
  agent: document_reviewer_agent
  context:
    - document_review_task


# =============================================================================
# REVIEWER ASSISTANT AGENT TASKS
# =============================================================================

reviewer_assistant_question_task:
  description: >
    Answer a reviewer's question about an application, policy, or eligibility.

    QUESTION: {question}

    CONTEXT (if provided):
    - Institution ID: {institution_id}
    - Application ID: {application_id}
    - Course ID: {course_id}

    STEPS:
    1. Analyze the question to determine what type of information is needed:
       - Eligibility questions: Use check_eligibility tool
       - Document questions: Use get_missing_documents tool
       - Comparison questions: Use compare_applicant tool
       - Requirement questions: Use get_admission_criteria tool
       - Policy questions: Use search_policies tool
       - Summary requests: Use get_application_summary tool

    2. Retrieve relevant information using the appropriate tools

    3. Synthesize the information into a clear, helpful response

    4. Include citations for any policy references

    5. Provide actionable recommendations where appropriate

    EXAMPLE QUESTIONS:
    - "Is this applicant eligible for conditional acceptance?"
    - "What documents are missing for this application?"
    - "What are the minimum requirements for BCom Accounting?"
    - "How does this applicant compare to accepted students?"

    Your final answer MUST be a JSON object with:
    - answer: Clear response to the question
    - citations: Array of sources/policies referenced
    - recommendations: Array of suggested actions (if applicable)
    - confidence: High/Medium/Low based on data availability
  expected_output: >
    JSON with answer, citations, recommendations, and confidence level
  agent: reviewer_assistant_agent


reviewer_eligibility_check_task:
  description: >
    Perform a detailed eligibility check for an application.

    Application ID: {application_id}
    Course ID: {course_id}

    STEPS:
    1. Use get_application_summary to retrieve applicant details
    2. Use get_admission_criteria to get course requirements
    3. Use check_eligibility to compare applicant against requirements
    4. Use compare_applicant to see how they rank against accepted students
    5. Use get_missing_documents to check document completeness

    PRODUCE A COMPREHENSIVE ELIGIBILITY REPORT including:
    - Overall eligibility status (Eligible/Conditional/Not Eligible)
    - APS comparison with requirement
    - Subject requirement check (especially Maths vs Maths Literacy)
    - Document status
    - Comparison with accepted students
    - Final recommendation with reasoning

    Your answer MUST include:
    - Clear eligibility verdict
    - Supporting evidence from each check
    - Any conditions or missing requirements
    - Recommendation for reviewer action
  expected_output: >
    Comprehensive eligibility report with verdict and recommendations
  agent: reviewer_assistant_agent


reviewer_application_summary_task:
  description: >
    Generate a comprehensive summary of an application for quick review.

    Application ID: {application_id}

    STEPS:
    1. Use get_application_summary to retrieve all application details
    2. Use get_missing_documents to check document status
    3. If course choices are present, use get_admission_criteria for each

    CREATE A REVIEWER-FRIENDLY SUMMARY including:
    - Applicant overview (name, contact, ID)
    - Academic profile (APS, key subjects, highlights)
    - Course choices with eligibility indication
    - Document status (complete/missing/flagged)
    - Application timeline
    - Any flags or concerns

    Format the summary for quick scanning by busy reviewers.
  expected_output: >
    Structured application summary optimized for reviewer workflow
  agent: reviewer_assistant_agent


# =============================================================================
# ANALYTICS TASKS
# =============================================================================

analytics_query_task:
  description: >
    Process a natural language analytics question for institution {institution_id}.

    QUESTION: {analytics_question}

    STEPS:
    1. Analyze the question to determine what data is needed
    2. Use generate_sql_query to convert the question to SQL
       - Ensure the query is properly scoped to institution_id
       - Use appropriate JOINs and aggregations
    3. Use execute_analytics_query to run the SQL
    4. Validate the results make sense for the question

    SPECIAL CASES:
    - For basic stats (total applications, status counts), use get_application_stats
    - For trend data, ensure proper date ordering
    - For comparisons, include meaningful labels

    Your final answer MUST be a JSON object with:
    - sql_query: The SQL that was executed
    - data: Array of result rows
    - row_count: Number of results
    - data_type: "categorical", "time_series", "proportion", or "comparison"
  expected_output: >
    JSON with sql_query, data array, row_count, and data_type classification
  agent: analytics_agent


analytics_visualization_task:
  description: >
    Create a Recharts visualization for the analytics results.

    ORIGINAL QUESTION: {analytics_question}
    SAVE CHART: {save_chart}
    PIN CHART: {pin_chart}

    Using the data from analytics_query_task, select the best chart type:

    CHART TYPE SELECTION:
    - data_type="categorical" -> Bar Chart (faculties, courses, campuses)
    - data_type="proportion" -> Pie Chart (status distribution, rates)
    - data_type="time_series" -> Line Chart (trends over time)
    - data_type="comparison" -> Bar Chart (comparing values)

    STEPS:
    1. Determine the appropriate chart type based on data_type
    2. Use the corresponding generate_*_chart tool
    3. If save_chart is true:
       - Use save_chart with institution_id={institution_id}
       - Set is_pinned={pin_chart}

    COLOR RULES:
    - Status data (accepted/pending/rejected) uses traffic light colors
    - Categorical data uses the standard palette
    - Time series uses primary blue color

    Your final answer MUST be a JSON object with:
    - chart_config: Complete Recharts configuration
    - chart_type: "bar", "pie", "line", or "area"
    - title: Chart title
    - saved: true/false
    - chart_id: UUID if saved, null otherwise
  expected_output: >
    JSON with chart_config, chart_type, title, saved status, and chart_id
  agent: analytics_agent
  context:
    - analytics_query_task


get_pinned_charts_task:
  description: >
    Retrieve all pinned charts for institution {institution_id}.

    Use get_saved_charts with pinned_only=true to fetch only the charts
    that should appear on the analytics dashboard.

    Your final answer MUST be a JSON object with:
    - charts: Array of saved chart objects
    - total: Count of pinned charts
  expected_output: >
    JSON with charts array and total count
  agent: analytics_agent


toggle_chart_pin_task:
  description: >
    Update the pinned status of chart {chart_id}.

    New pinned status: {is_pinned}

    Use toggle_chart_pin to update the chart's pinned status.
    Pinned charts appear on the main analytics dashboard.

    Your final answer MUST confirm:
    - chart_id that was updated
    - new pinned status
    - success/failure message
  expected_output: >
    Confirmation of pin status update
  agent: analytics_agent
