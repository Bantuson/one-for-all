account_creation_task:
  description: >
    Use provided profile data for account creation:
    - Full Name: {full_name}
    - Email: {email}
    - Mobile: {mobile_number}
    - WhatsApp: {whatsapp_number}
    Verify information is correct. Select OTP method (WhatsApp preferred).
    Your final answer MUST include: username, email, cellphone, chosen_otp_method.
  expected_output: >
    A structured JSON object with user credentials ready for OTP sending.
  agent: identity_auth_agent

otp_verification_task:
  description: >
    Send the OTP based on the user's selected method (email, SMS, or WhatsApp).
    The OTP sending tools (sendgrid_otp_sender, sms_otp_sender, send_whatsapp_otp)
    will AUTOMATICALLY generate and store the OTP in the database - do NOT
    fabricate OTP codes.

    After sending, prompt the user to provide the OTP they received.

    Use the verify_otp tool to validate the code against the database:
    - verify_otp(identifier, code) returns "OTP_VALID" or "OTP_INVALID: reason"
    - identifier must match exactly what was used when sending (email or phone)

    ONLY after receiving "OTP_VALID" response:
    - Create user account via supabase_user_store
    - Create 24hr session via supabase_session_create

    If verification fails, inform the user of the specific reason and offer
    to resend using resend_otp_check tool first.

    Your final answer MUST confirm successful account creation with session token.
  expected_output: >
    Confirmation message with session token (only after OTP_VALID verification).
  agent: identity_auth_agent

collect_personal_info_task:
  description: >
    Use provided profile data for personal information:
    - Full Name: {full_name}
    - SA ID Number: {id_number}
    - Date of Birth: {date_of_birth}
    - Gender: {gender}
    - Citizenship: {citizenship}
    - Home Address: {physical_address}
    - Email: {email}
    - Cellphone: {mobile_number}
    - Province: {province}
    - Home Language: {home_language}
    Confirm all data is correct. Your final answer MUST be a structured JSON.
  expected_output: >
    SA-standardised applicant personal information.
  agent: application_intake_agent

collect_academic_info_task:
  description: >
    Use provided academic data from profile:
    - Matric Results: {matric_results}
    - Total APS Score: {total_aps_score}
    - Academic Highlights: {academic_highlights}
    Confirm data is correct. Your final answer MUST be a JSON matching SA requirements.
  expected_output: >
    Detailed SA academic history JSON with APS score.
  agent: application_intake_agent

collect_documents_task:
  description: >
    Use provided document status from profile:
    - Available: {documents_available}
    - Missing: {documents_missing}
    Mark available documents as "uploaded", missing as "pending".
    Do NOT block workflow for missing documents.
    Your final answer MUST include document metadata with status per document.
  expected_output: >
    Document metadata JSON with status field per document (uploaded/pending).
  agent: application_intake_agent
  context:
    - collect_personal_info_task
    - collect_academic_info_task

program_selection_task:
  description: >
    Use provided course selections from profile:
    - Course Choices: {course_choices}
    - Primary Institution: {primary_institution}
    The course_choices array contains first and second choice with priority.
    Verify selections align with APS score ({total_aps_score}).
    Your final answer MUST include first_choice and second_choice per university.
  expected_output: >
    JSON list of universities with first_choice and second_choice course details.
  agent: application_intake_agent
  context:
    - collect_academic_info_task

rag_research_task:
  description: >
    Evaluate eligibility for each course choice using profile data:
    - APS Score: {total_aps_score}
    - Matric Results: {matric_results}
    - Course Choices: {course_choices}

    The course_choices array may contain up to 3 choices:
    - Priority 1: First choice (original)
    - Priority 2: Second choice (original)
    - Priority 3: Fallback choice (use when first rejected)

    For EACH course choice:
    1. Check APS score against minimum requirement
    2. Check SUBJECT requirements (CRITICAL: Maths Literacy is NOT accepted for
       programmes requiring "Maths" - only pure Mathematics qualifies)
    3. Check language/other specific requirements

    ELIGIBILITY SCENARIOS:
    A) If FIRST-CHOICE ELIGIBLE: Use first + second as final choices
    B) If FIRST-CHOICE INELIGIBLE:
       - Mark as REJECTED with clear reason
       - Promote SECOND-CHOICE to NEW first-choice
       - Use FALLBACK (priority 3) as NEW second-choice if available
       - If no fallback provided, list eligible alternatives for prospect

    CRITICAL: Applications MUST have exactly TWO eligible choices.

    Your final answer MUST include:
    - original_first_choice_eligible (true/false) with reason
    - final_first_choice (programme name)
    - final_second_choice (programme name)
    - rejection_reasons (if any)
    - both_choices_verified (must be true)
  expected_output: >
    JSON with final_first_choice, final_second_choice, rejection_reasons,
    original_eligibility, and both_choices_verified=true.
  agent: rag_specialist_agent
  context:
    - collect_academic_info_task
    - program_selection_task

application_compilation_task:
  description: >
    Compile per university: personal info, academic info, documents (with status),
    BOTH course choices from RAG task (final_first_choice, final_second_choice).

    CRITICAL: Every application MUST have exactly TWO course choices:
    - first_choice: Primary programme (verified eligible)
    - second_choice: Backup programme (verified eligible)

    Use the RAG task output which has already verified eligibility and
    handled any promotions/replacements if original first choice was rejected.

    Validate all fields and prepare submission payload.
  expected_output: >
    Validated application JSON with BOTH first_choice and second_choice courses.
  agent: submission_agent
  context:
    - collect_personal_info_task
    - collect_academic_info_task
    - collect_documents_task
    - program_selection_task
    - rag_research_task

application_submission_task:
  description: >
    Submit to ALL selected universities using application_submission_tool.

    CRITICAL: Each submission MUST include BOTH choices:
    - first_choice: Primary programme
    - second_choice: Backup programme

    Do NOT submit applications with only one choice.

    Your final answer MUST include per university:
    - university name
    - application_id
    - first_choice_programme and status
    - second_choice_programme and status
    - overall submission status
  expected_output: >
    JSON with university, application_id, first_choice, second_choice, status.
  agent: submission_agent
  context:
    - application_compilation_task

ask_if_apply_for_nsfas_task:
  description: >
    Check profile for NSFAS eligibility:
    - NSFAS Eligible: {nsfas_eligible}
    - Household Income: {household_income}
    - SASSA Recipient: {sassa_recipient}

    DECISION LOGIC (check in order):
    1. If nsfas_eligible is FALSE or "No" → return NO_NSFAS (income too high)
    2. If postgrad programme → return NO_NSFAS (NSFAS is for undergrad only)
    3. If nsfas_eligible is TRUE and undergrad → return YES_NSFAS

    CRITICAL: High-income applicants (nsfas_eligible=false) must NOT apply for NSFAS.

    Your final answer MUST be exactly: "YES_NSFAS" or "NO_NSFAS"
  expected_output: >
    YES_NSFAS or NO_NSFAS
  agent: application_intake_agent
  context:
    - program_selection_task

nsfas_collection_task:
  description: >
    FIRST: Check the ask_if_apply_for_nsfas_task result in your context.

    IF the result was "NO_NSFAS":
      - Do NOT collect any NSFAS data
      - Do NOT call any tools
      - Return exactly: {"nsfas_skipped": true, "reason": "Applicant not eligible for NSFAS"}

    IF the result was "YES_NSFAS":
      Use profile data for NSFAS application:
      - Guardian Employment: {guardian_employment}
      - Household Income: {household_income}
      - SASSA Recipient: {sassa_recipient}
      - Disability Grant: {disability_grant}
      Reuse personal info, academic records from prior tasks.
      Compile NSFAS-specific fields. Store via supabase_nsfas_documents_store.
      Your final answer MUST be complete NSFAS application JSON.
  expected_output: >
    NSFAS application JSON with reused and new data combined, OR
    {"nsfas_skipped": true, "reason": "..."} if applicant not eligible.
  agent: nsfas_agent
  context:
    - ask_if_apply_for_nsfas_task
    - collect_personal_info_task
    - collect_academic_info_task
    - collect_documents_task

nsfas_submission_task:
  description: >
    FIRST: Check the nsfas_collection_task result in your context.

    IF the result contains "nsfas_skipped": true:
      - Do NOT submit any NSFAS application
      - Do NOT call any tools
      - Return exactly: {"nsfas_skipped": true, "reason": "Applicant not eligible for NSFAS - no submission required"}

    IF valid NSFAS application data exists:
      Submit NSFAS application via nsfas_application_submission_tool.
      Return: nsfas_application_id and submission status.
      Store application metadata in Supabase.
  expected_output: >
    NSFAS submission confirmation with nsfas_application_id, OR
    {"nsfas_skipped": true, "reason": "..."} if applicant not eligible.
  agent: nsfas_agent
  context:
    - nsfas_collection_task

university_status_check_task:
  description: >
    Retrieve status updates for university applications using
    application_status_tool.
    Your final answer MUST summarise the latest known status.
  expected_output: >
    Latest status update.
  agent: submission_agent

nsfas_status_check_task:
  description: >
    FIRST: Check the nsfas_submission_task result in your context.

    IF the result contains "nsfas_skipped": true:
      - Do NOT check any NSFAS status
      - Return exactly: "NSFAS application was not submitted - applicant not eligible for NSFAS funding due to household income exceeding threshold."

    IF NSFAS application was submitted:
      Retrieve the latest NSFAS application status using nsfas_status_tool.
      Your final answer MUST summarise:
        - current NSFAS status
        - any outstanding requirements
        - next steps for the student
  expected_output: >
    Latest NSFAS status summary, OR skip message if applicant not eligible.
  agent: nsfas_agent
  context:
    - nsfas_submission_task


document_review_task:
  description: >
    Review all uploaded documents for application {application_id}.

    STEPS:
    1. Use get_application_documents to fetch all documents for this application
    2. For each document, check:
       - Legibility: Can text/images be clearly read?
       - Completeness: Are all required pages present?
       - Accuracy: Does information match the applicant's details?
       - Validity: Check expiry dates where applicable (ID, certificates)

    3. For each document, make a decision:
       - Use document_approve_tool if the document is valid and complete
       - Use document_flag_tool if there are issues, providing a CLEAR reason

    FLAGGING REASONS MUST BE SPECIFIC AND ACTIONABLE:
    ✓ Good: "ID document image is too blurry - please upload a clearer photo"
    ✓ Good: "Matric certificate is missing page 2 - please upload complete document"
    ✗ Bad: "Document has issues"
    ✗ Bad: "Not acceptable"

    Your final answer MUST be a JSON with:
    - reviewed_count: Total documents reviewed
    - approved: Array of approved document IDs
    - flagged: Array of objects with {document_id, document_type, reason}
  expected_output: >
    JSON with reviewed_count, approved (array of IDs), flagged (array with document_id, document_type, reason)
  agent: document_reviewer_agent


document_flagging_notification_task:
  description: >
    For each flagged document from the document_review_task context,
    compose and send a notification to the applicant explaining what
    needs to be corrected and how to resubmit.

    NOTIFICATION GUIDELINES:
    1. Use applicant's preferred contact method (WhatsApp, Email, SMS)
    2. Be polite and helpful in tone
    3. Clearly state WHICH document has the issue
    4. Explain WHAT is wrong (use the flag_reason)
    5. Provide clear instructions on HOW to resubmit

    TEMPLATE STRUCTURE:
    Subject: Action Required - Document Review for Your Application

    Dear [Applicant Name],

    We have reviewed your application documents and need you to resubmit
    the following:

    Document: [Document Type]
    Issue: [Flag Reason]
    Action: Please upload a new version that addresses the issue above.

    [Include upload instructions or link]

    If you have questions, please contact support.

    Your final answer MUST confirm:
    - Number of notifications sent
    - Contact methods used
    - Brief summary of each notification
  expected_output: >
    Confirmation of notifications sent with message content summary
  agent: document_reviewer_agent
  context:
    - document_review_task


# =============================================================================
# APS RANKING AGENT TASKS
# =============================================================================

aps_calculation_task:
  description: >
    Calculate the APS (Admission Point Score) for the provided application.

    Use the academic_info from the application which contains matric subjects
    and their percentage marks in the following format:
    {"subjects": [{"name": "Mathematics", "percentage": 75}, ...]}

    STEPS:
    1. Use calculate_aps tool with the academic_info JSON
    2. The tool applies the standard SA APS scale:
       - 80-100%: 7 points
       - 70-79%: 6 points
       - 60-69%: 5 points
       - 50-59%: 4 points
       - 40-49%: 3 points
       - 30-39%: 2 points
       - 0-29%: 1 point
    3. Life Orientation is weighted at 50% (max 3.5 points)
    4. Total APS = Sum of 6 best subjects + (LO * 0.5)

    Your final answer MUST be a JSON with:
    - application_id: The application being processed
    - total_aps: The calculated APS score (integer)
    - breakdown: Subject-by-subject point allocation
    - life_orientation: LO subject details and contribution
    - subjects_counted: Number of subjects used in calculation
  expected_output: >
    JSON with total_aps, breakdown, life_orientation, and calculation details.
  agent: aps_ranking_agent


aps_eligibility_task:
  description: >
    Check eligibility for the applicant's selected courses based on their APS.

    STEPS:
    1. Use get_course_requirements to fetch minimum APS and subject requirements
    2. Use compare_to_cutoff to check APS against course minimum
    3. Use check_subject_requirements to verify mandatory subject levels
    4. For comprehensive check, use check_full_eligibility

    ELIGIBILITY STATUS CODES:
    - "highly_eligible": APS exceeds minimum by 5+ points
    - "eligible": APS meets or exceeds minimum
    - "borderline": APS is 1-3 points below minimum (may be considered)
    - "ineligible_aps": APS significantly below requirement
    - "ineligible_subjects": Subject requirements not met

    IMPORTANT: Mathematics vs Mathematical Literacy
    - Programmes requiring "Mathematics" will NOT accept "Mathematical Literacy"
    - Check subject_requirements carefully for this distinction

    Your final answer MUST be a JSON with:
    - course_id: The course being assessed
    - course_name: Name of the course
    - applicant_aps: The applicant's APS
    - min_aps_required: Course minimum requirement
    - eligibility_status: One of the status codes above
    - subject_check: Results of subject requirements verification
    - recommendation: Clear guidance for the applicant
  expected_output: >
    JSON with eligibility_status, subject_check, and recommendation.
  agent: aps_ranking_agent
  context:
    - aps_calculation_task


aps_ranking_task:
  description: >
    Rank multiple applications by their calculated APS scores.

    This task processes a batch of applications (from agent_session.target_ids)
    and produces a ranked list for admissions processing.

    STEPS:
    1. Process each application in target_ids
    2. Calculate APS for each using calculate_aps
    3. Store each calculation via store_aps_calculation
    4. Sort applications by APS (descending)
    5. Assign rank positions (1 = highest APS)

    RANKING CONSIDERATIONS:
    - Ties: Applications with same APS share the same rank
    - Cutoff: Identify applications above/below course minimum
    - Subject requirements: Note any with subject deficiencies

    Your final answer MUST be a JSON with:
    - total_processed: Number of applications processed
    - ranked_applications: Array sorted by APS with:
      - rank: Position (1 = highest)
      - application_id: Application ID
      - applicant_name: (if available)
      - total_aps: Calculated APS
      - meets_cutoff: Boolean for course minimum
      - subject_eligible: Boolean for subject requirements
    - summary:
      - above_cutoff_count: Applications meeting minimum
      - below_cutoff_count: Applications below minimum
      - avg_aps: Average APS of batch
      - highest_aps: Top APS score
      - lowest_aps: Bottom APS score
  expected_output: >
    JSON with ranked_applications array and summary statistics.
  agent: aps_ranking_agent
  context:
    - aps_calculation_task
    - aps_eligibility_task